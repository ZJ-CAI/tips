
1.数组创建    
a = np.array([[1, 2], [3, 4]])   手写创建
a = np.arange(0,12,1).reshape(1,1,4,3)   
x = np.empty((2,2), dtype = np.float)  
x = np.zeros((2,2), dtype = np.int8)
x = np.ones((2,2), dtype = np.int8) 

x =  [1,2,3]                 根据列表创建
x =  [(1,2,3),(4,5)]         根据元组列表创建
a = np.asarray(x) 

2.切片和索引

 a = np.arange(10) 
 b = a[2:7:2]    从索引 2 开始到索引 7 停止，间隔为 2
 print (x[x >  5])


 使用 ~（取补运算符）来过滤 NaN。
 a = np.array([np.nan,  1,2,np.nan,3,4,5])  
 print(a,'aaaa')
 print (a[~np.isnan(a)])

 根据行列来索引特定值
x = np.array([[  0,  1,  2],[  3,  4,  5],[  6,  7,  8],[  9,  10,  11]])
x[[1,1],[2,0]]=100
 print(x)


3.数组迭代 
 a = np.arange(6).reshape(2,3)
 行优先,第一行检索完了后检索第二行
 for x in np.nditer(a):
     print (x, end=", " )
 print('\n')

 列优先。第一列检索完了后检索第二列
 for x in np.nditer(a, order =  'F'): 
     print(x,end=',')
 print('\n')

 以下两种方法也有类似的功能
 print(a.T.reshape(2*3))
 print (a.flatten(order='F'))


 4.修改数组形状
numpy.rollaxis: 函数向后滚动特定的轴到一个特定位置

a=np.arange(3*128*256).reshape(3,128,256)
print(a.shape)
a=np.rollaxis(a,2,0)
print(a.shape)

numpy.swapaxes 函数用于交换数组的两个轴

a=np.arange(3*128*256).reshape(3,128,256)
a=np.swapaxes(a,0,2)


np.transpose也可以用来交换数组维度
a_t = np.transpose(a, axes=(1,2,0))


 修改数组维度
 1.1增加维度numpy.expand_dims(arr, axis)
a=np.arange(3*2).reshape(3,2,1)
a=np.expand_dims(a,axis=0)

1.2 向数组添加元素insert
a=np.insert(a,1,[11,12],axis = 0)   第一行插入，按行
a=np.insert(a,1,[11],axis = 1)   第一列插入，按列

2.1 squeeze删除维度,只能删除长度为1的维度
a=np.squeeze(a,axis=0)
print(a.shape)

2.2 delete删除数组元素，没有限制
a=np.delete(a,1,axis = 0) 
a=np.delete(a,1,axis = 1) 


3.数组拼接np.concatenate
a=np.arange(4).reshape(2,2)
b=np.arange(4,8,1).reshape(2,2)
c=np.concatenate((a,b),axis=1)
读取和存储numpy格式的文件

1.npy文件
直接就能读出数组
data=np.load(‘data.npy’)
np.save("data.npy", data)


2.npz文件
数组存储在对应的key值里
headpose=np.load('test.npz')
np.savez(save_path, face = headpose)


3.pkl文件
直接读取数组
Import pickle
f=open('test.pkl','rb')
audio=pickle.load(f)
pickle.dump(audio, open(out_file, 'wb'))

4.mat文件
数组以字典的形式存储，需要用key值读取数组
From scipy.io import loadmat
From scipy.io import savedmat



